---
title: InnoDB相关part6 InnoDB 存储引擎中的锁  
date: 2021-08-09 
---    


InnoDB存储引擎实现了如下两种标准的行级锁:  

+ 共享锁(S Lock), 允许事务读一行数据
+ 排他锁(X Lock), 允许事务删除或更新一行数据  

如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况位锁兼容。但若有其他的事务T3想获得行r 的排他锁，则必须等待事务T1T2释放行r上的共享锁——这种情况称为锁不兼容。  


此外，InnoDB存储引擎支持多粒度(Intention Lock)上进行锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。  

### 解决Phantom Problem  

在默认的事务隔离级别下，即REPEATABLE READ下, InnoDB存储引擎采用Next-Key Locking机制避免Phantom Problem。这点可能不同与其他的数据库  

Phantom Problem是指在同一事务下，连续执行两次同样的sql语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。  



*在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，则MySQL会抛出异常*  


```sql
CREATE TABLE t3 (
    a INT AUTO_INCREMENT,
    b INT,
    KEY(b, a)
) ENGINE=InnoDB;


ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
```  


### 脏读

在理解脏读(Dirty Read)之前，需要理解脏数据的概念。但是脏数据和之前所介绍的脏页完全是两种不同的概念。脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页跟磁盘中的页是不一致的，当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中。而所谓的脏数据是指事务对缓冲池中的行记录的修改，并且还没有被提交(commit)。

如果读到了脏数据，即一个事务可以读到另一个事务中未提交的数据，则显然违反了数据库的隔离性。  


### 不可重复读  

不可重复读是指在一个事务内多次读取同一个数据集合.在这个事物还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。  

不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是违反了数据库事务一致性的要求。  


