---
title: InnoDB相关part6 InnoDB 存储引擎中的锁  
date: 2021-08-09 
---    


InnoDB存储引擎实现了如下两种标准的行级锁:  

+ 共享锁(S Lock), 允许事务读一行数据
+ 排他锁(X Lock), 允许事务删除或更新一行数据  

如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况位锁兼容。但若有其他的事务T3想获得行r 的排他锁，则必须等待事务T1T2释放行r上的共享锁——这种情况称为锁不兼容。  


此外，InnoDB存储引擎支持多粒度(Intention Lock)上进行锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。  

### 解决Phantom Problem  

在默认的事务隔离级别下，即REPEATABLE READ下, InnoDB存储引擎采用Next-Key Locking机制避免Phantom Problem。这点可能不同与其他的数据库  

Phantom Problem是指在同一事务下，连续执行两次同样的sql语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。  



*在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。如果不是第一个列，则MySQL会抛出异常*  


```sql
CREATE TABLE t3 (
    a INT AUTO_INCREMENT,
    b INT,
    KEY(b, a)
) ENGINE=InnoDB;


ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
```  


### 脏读

在理解脏读(Dirty Read)之前，需要理解脏数据的概念。但是脏数据和之前所介绍的脏页完全是两种不同的概念。脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页跟磁盘中的页是不一致的，当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中。而所谓的脏数据是指事务对缓冲池中的行记录的修改，并且还没有被提交(commit)。

如果读到了脏数据，即一个事务可以读到另一个事务中未提交的数据，则显然违反了数据库的隔离性。  


### 不可重复读  

不可重复读是指在一个事务内多次读取同一个数据集合.在这个事物还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。  

不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是违反了数据库事务一致性的要求。    


InnoDB中通过使用Next-Key Lock算法来避免不可重复读的问题，在Next-Key Lock算法下，对索引的扫描，不仅仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围(gap)。因此在这个范围内的插入都是不允许的。这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。   


### 死锁  


死锁是指两个或两个以上的事务在执行的过程中，因争夺锁资源而造成的一种互相等待的现象。  


解决死锁问题最简单的一种方法是超时，等待时间超过某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。  

除了超时机制，数据库普遍采用wait-for graph等待图的方式来进行死锁检测。  

wait-for graph要求数据库保存一下两种信息：  

+ 锁的信息链表  
+ 事务等待链表  

通过上述链表可以构造一张图，如果这个图存在回路，就代表存在死锁。  
用的是深搜  

InnoDB并不会回滚大部分错误异常，但是死锁除外。  

事务发生死锁跟以下几点因素有关：  
+ 系统中事务的数量，数量越多发生死锁的概率越大 
+ 每个事务操作的数量，每个事务操作的数量越多，发生死锁的概率越大
+ 操作数据的集合，越小则发生死锁的概率越大  

###  purge    

delete和update操作可能并不直接删除原有的数据。purge用于最终完成delete和update操作，这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事务可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。   




