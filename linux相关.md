---
title: Linux相关    
date: 2022-01-21 
---    

Linux中0 1 2 是文件描述符


| 名称 | 代码 | 操作符 | Java中表示 | Linux 下文件描述符（Debian 为例) |
|:---:|:---:|:---:|:---:|:---:|
| 标准输入(stdin) | 0 | < 或 << System.in | /dev/stdin -> /proc/self/fd/0 -> /dev/pts/0 |
| 标准输出(stdout) | 1 |>, >>, 1> 或 1>> System.out | /dev/stdout -> /proc/self/fd/1 -> /dev/pts/0 |
| 标准错误输出(stderr) | 2 | 2> 或 2>> System.err | /dev/stderr -> /proc/self/fd/2 -> /dev/pts/0 |


上面表格引用自这里
从上表看的出来，我们平时使用的

echo "hello" > t.log 
1
其实也可以写成

echo "hello" 1> t.log
1
B.关于2>&1的含义
（关于输入/输出重定向本文就不细说了，不懂的可以参考这里，主要是要了解> < << >> <& >& 这6个符号的使用）

含义：将标准错误输出重定向到标准输出
符号>&是一个整体，不可分开，分开后就不是上述含义了。
比如有些人可能会这么想：2是标准错误输入，1是标准输出，>是重定向符号，那么"将标准错误输出重定向到标准输出"是不是就应该写成"2>1"就行了？是这样吗？
如果是尝试过，你就知道2>1的写法其实是将标准错误输出重定向到名为"1"的文件里去了
写成2&>1也是不可以的
C.为什么2>&1要放在后面
考虑如下一条shell命令

nohup java -jar app.jar >log 2>&1 &
1
(最后一个&表示把条命令放到后台执行，不是本文重点，不懂的可以自行Google)
为什么2>&1一定要写到>log后面，才表示标准错误输出和标准输出都定向到log中？
我们不妨把1和2都理解是一个指针,然后来看上面的语句就是这样的：

本来1----->屏幕 （1指向屏幕）
执行>log后， 1----->log (1指向log)
执行2>&1后， 2----->1 (2指向1，而1指向log,因此2也指向了log)
再来分析下

nohup java -jar app.jar 2>&1 >log &
1
本来1----->屏幕 （1指向屏幕）
执行2>&1后， 2----->1 (2指向1，而1指向屏幕,因此2也指向了屏幕)
执行>log后， 1----->log (1指向log，2还是指向屏幕)
所以这就不是我们想要的结果。
简单做个试验测试下上面的想法：
java代码如下：

public class Htest {
    public static void main(String[] args) {
        System.out.println("out1");
        System.err.println("error1");
    }
}
1
2
3
4
5
6
javac编译后运行下面指令：

java Htest 2>&1 > log
1
你会在终端上看到只输出了"error1"，log文件中则只有"out1"

D.每次都写">log 2>&1"太麻烦，能简写吗？
有以下两种简写方式

&>log
>&log
1
2
比如上面小节中的写法就可以简写为：

nohup java -jar app.jar &>log &
1
上面两种方式都和">log 2>&1"一个语义。
那么 上面两种方式中&>和>&有区别吗？
语义上是没有任何区别的，但是第一中方式是最佳选择，一般使用第一种


————————————————
版权声明：本文为CSDN博主「一个行走的民」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhaominpro/article/details/82630528